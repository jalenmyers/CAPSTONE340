\documentclass{article}

\usepackage{tikz} 
\usetikzlibrary{automata, positioning, arrows} 

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{color}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{tikz-cd}
\tikzcdset{arrows={>=latex}, self/.style={loop, out=55, in=125, distance=8mm}}

  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}
\usepackage[utf8]{inputenc}                                                    
\usepackage[T1]{fontenc}                                                       

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newtheoremstyle{theorem}
  {\topsep}   % ABOVESPACE
  {\topsep}   % BELOWSPACE
  {\itshape\/}  % BODYFONT
  {0pt}       % INDENT (empty value is the same as 0pt)
  {\bfseries} % HEADFONT
  {.}         % HEADPUNCT
  {5pt plus 1pt minus 1pt} % HEADSPACE
  {}          % CUSTOM-HEAD-SPEC
\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}

\title{CPSC-354 Report}
\author{Jalen Myers  \\ Chapman University}

\date{\today} 

\usepackage{forest}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\setcounter{tocdepth}{3}
\tableofcontents

\section{Introduction}\label{intro}

\section{Week by Week}\label{homework}

\subsection{Week 1}

\subsubsection{The MU Puzzle}
The MU Puzzle, introduced by Douglas Hofstadter in \textit{Gödel, Escher, Bach}, is a formal string-rewriting puzzle. You start with the axiom \textbf{MI} and attempt to transform it into the target string \textbf{MU} using four simple rules. At first glance, it appears to be a game of clever substitutions and expansions, but underneath lies a lesson about \textbf{formal systems}, \textbf{invariants}, and \textbf{proof by impossibility}. The puzzle demonstrates that even though the rules allow endless local manipulations, there are hidden global constraints that block certain outcomes. In this case, the invariant is the number of I's modulo 3, which prevents ever reaching MU. It is less about ``finding the clever sequence’’ and more about recognizing when a goal is \textbf{provably impossible}.

\paragraph{Rules:}
\begin{enumerate}
  \item Append U after I: \quad $xI \to xIU$
  \item Double after M: \quad $Mx \to Mxx$
  \item Swap III for U: \quad $xIIIy \to xUy$
  \item Delete UU: \quad $xUUy \to xy$
\end{enumerate}

\paragraph{Key invariant (why MU is impossible):}  
Starting with $MI \to MII \to MIIII \to MUIUUIU$, no matter how the rules are applied, the number of I’s never reaches zero. For example:
\[
MI \to MII \to MIIII \equiv 1 \pmod{3}, \quad 
MIIII \to MIU \ (I=1)
\]
The invariant that the number of I’s modulo 3 is never 0 prevents reaching MU.

\paragraph{Rule interactions with I:}
\begin{itemize}
  \item Rule 1: Does not touch I’s, but can create UU opportunities for Rule 4 cleanup.
  \item Rule 2: The only way to increase I’s; preserves the parity cycle $\{1,2\}$ modulo 3.
  \item Rule 3: The only way to reduce I’s; reduces them by 3 at a time, keeping modulo 3 unchanged.
  \item Rule 4: Purely cosmetic with respect to I’s; manages U’s only.
\end{itemize}
Thus, I’s are the crucial resource; U’s are merely bookkeeping.

\paragraph{Example derivation:}
\[
MI \ (I=1) \xrightarrow{\text{Rule 2}} MII \ (I=2) \xrightarrow{\text{Rule 2}} MIIII \ (I=4 \equiv 1 \pmod{3})
\]
\[
MIIII \xrightarrow{\text{Rule 3}} MIU \ (I=1) \xrightarrow{\text{Rule 1}} MIUU \ (I=1)
\]
Deleting UU later still leaves $I=1$. The cycle alternates between $I \equiv 1$ and $I \equiv 2$, never reaching 0.

\paragraph{Starting with Rules 1 or 2:}  
You can start with either Rule 1 or Rule 2, but it does not matter for reachability of MU. The invariant blocks MU either way.

\subsubsection{Rule Modification: UU $\to$ I}

If Rule 4 is modified to $xUUy \to xIy$, then the invariant breaks down. For instance:
\[
MU \xrightarrow{\text{Rule 2}} MUU \xrightarrow{\text{Rule 4$^\prime$}} MI
\]
This allows us to get from MU back to MI in two steps. More generally, this alteration lets us change the number of I’s modulo 3, opening paths that were previously impossible.

\subsubsection{Local Rules, Global Truths}

This puzzle is a tiny string rewriting system. The surprising aspect is that local rewrites can create global invariants (like $I \pmod{3}$) that dictate what outcomes are possible. The method of solving involves:
\begin{enumerate}
  \item Finding a conserved quantity,
  \item Classifying each rule’s effect on that quantity,
  \item Concluding reachability or non-reachability of the target.
\end{enumerate}
A single change in the rule set (e.g., replacing UU deletion with UU $\to$ I) completely alters the invariant landscape, showing how local edits ripple globally.

\subsubsection{Conclusion}

The MU Puzzle highlights how simple rules can create surprising limits. By tracking the number of I’s, we saw that modular arithmetic exposes an invariant invisible at first glance. Rules 1 and 4 do not change I’s, Rule 2 doubles them, and Rule 3 reduces them by three. Together, they trap the system in a cycle that never reaches zero I’s, so MU cannot be produced.  

Changing just one rule, however, completely alters the system: the invariant breaks down, and new possibilities emerge. This shift shows the deeper lesson: local changes ripple globally, and sometimes the only way to understand a system is to invent a new measuring stick. In the end, the puzzle is less about actually getting to MU and more about learning how formal reasoning and invariants reveal truths that trial-and-error never could.

\subsection{Week 2}

\subsubsection{Rewriting ARSs}
ARSs (Abstract Rewriting Systems)

\paragraph{List of ARSs:}
\begin{enumerate}
  \item $A = \{\}.$
  \item $A = \{a\}\quad\text{and}\quad R = \{\}.$
  \item $A = \{a\}\quad \text{and} \quad R = \{(a,a)\}.$
  \item $A = \{a,b,c\} \quad \text{and} \quad R = \{(a,b), (a,c)\}.$
  \item $A = \{a,b\} \quad \text{and} \quad R = \{(a,a), (a,b)\}.$
  \item $A = \{a,b,c\} \quad \text{and} \quad R = \{(a,b), (b,b), (a,c)\}.$
  \item $A = \{a,b,c\} \quad \text{and} \quad R = \{(a,b), (b,b), (a,c), (c,c)\}.$
\end{enumerate}

\subsubsection{ARSs with drawings and Explanations:}
\begin{enumerate}
    \item $A=\varnothing.$\\[2pt]
\text This systems is terminating, confluent and has unique normal forms, because there are no elements and no rewrite rules. Nothing can happen.

  \item $A=\{a\},\; R=\{\}.$\\[2pt]
  \[
  \begin{tikzcd}
    a 
  \end{tikzcd}
  \]
  \text We have one element a, but no rules. Since no rewrites are possible, a is already normal form. The system is terminating, confluent and has a unique normal form, which is just a.

  \item $A=\{a\},\; R=\{(a,a)\}.$\\[2pt]
  \[
  \begin{tikzcd}
    a \arrow[self, from=1-1, to=1-1]
  \end{tikzcd}
  \]
  \text Now a rewrites to itself. This means the system is not terminating because you can loop forever. But, it is trivially confluent, since there are no diverging rewrite paths. There is no normal form, because it can always be rewritten again. It does not have unique normal forms.

  \item $A=\{a,b,c\},\; R=\{(a,b),(a,c)\}.$\\[2pt]
  \[
  \begin{tikzcd}[column sep=2.2em]
    a \arrow[r] \arrow[dr] & b \\
    & c
  \end{tikzcd}
  \]
\text Here you can rewrite to two options. Since neither can be rewritten further, the system is terminating. However, it is not confluent because you can reduce to two different irreducible terms. As a result, it does not have unique normal forms.

  \item $A=\{a,b\},\; R=\{(a,a),(a,b)\}.$\\[2pt]
  \[
  \begin{tikzcd}[column sep=2.2em]
    a \arrow[r] & b \\
    \arrow[self, from=1-1, to=1-1]
  \end{tikzcd}
  \]
  \text In this case, you can either loop back to itself or reduce. The presence of the self-loop makes the system non-terminating. But it is still confluent, because both paths eventually lead to it, and it is the only normal form. Even though the system does not terminate in general, it does have a unique normal form.

  \item $A=\{a,b,c\},\; R=\{(a,b),(b,b),(a,c)\}.$\\[2pt]
  \[
  \begin{tikzcd}[column sep=2.2em]
            & a \arrow[dl] \arrow[dr] & \\
        b   &                         & c \\
    \arrow[self, from=2-1, to=2-1]
  \end{tikzcd}
  \]
  \text Here, you can reduce to either two opetions. The element of one of them loops onto itself and so is not a normal form, while the other is irreducible and therefore a normal form. Because of this loop, the system is not terminating, and because it can reduce to either a looping form, the system is not confluent and does not have a unique normal forms.

  \item $A=\{a,b,c\},\; R=\{(a,b),(b,b),(a,c),(c,c)\}.$\\[2pt]
  \[
  \begin{tikzcd}[column sep=2.2em]
            & a \arrow[dl] \arrow[dr] & \\
        b   &                         & c \\
    \arrow[self, from=2-1, to=2-1]
    \arrow[self, from=2-3, to=2-3]
  \end{tikzcd}
  \]
  \text This case can either go to two forms but both can loop on themselves. That means there are no normal forms at all. The system is not terminating, not confluent, and has no unique normal forms.
\end{enumerate}

\subsubsection{Mapping ARSs Covering All 8 Property Combinations:}
\text Below is a classification of the 8 combinations of 
\emph{confluence}, \emph{termination}, and \emph{unique normal forms}.
We can match each with one of our ARSs whenever possible.
Some rows are marked impossible due to logical constraints.

\begin{enumerate}
  \item \textbf{Confluent, Terminating, Unique NFs:}
  Example: ARS \#2 with $A=\{a\}, R=\{\}$.  
  \[
  \begin{tikzcd}
    a
  \end{tikzcd}
  \]
  This system terminates immediately and is trivially confluent, and $a$ is the unique normal form.

  \item \textbf{Confluent, Terminating, No Unique NFs:}
  Impossible. If an ARS is both terminating and confluent, then it must have unique normal forms.

  \item \textbf{Confluent, Non-terminating, Unique NFs:}
  Example: ARS \#5 with $A=\{a,b\}, R=\{(a,a),(a,b)\}$.  
  \[
  \begin{tikzcd}[column sep=2.2em]
    a \arrow[r] & b \\
    \arrow[self, from=1-1, to=1-1]
  \end{tikzcd}
  \]
  Although $a$ can loop forever both $a$ and $b$ reduce to the same unique normal form $b$, so the system is confluent with unique NFs.

  \item \textbf{Confluent, Non-terminating, No Unique NFs:}
  Example: ARS \#3 with $A=\{a\}, R=\{(a,a)\}$.  
  \[
  \begin{tikzcd}
    a \arrow[self, from=1-1, to=1-1]
  \end{tikzcd}
  \]
  The system has an infinite loop so it does not terminate, and since $a$ never reaches a normal form there are no unique normal forms. It is still trivially confluent.
  
  \item \textbf{Non-confluent, Terminating, Unique NFs:}
  Impossible. If every eement has a unique normal form, then reductions from any peak must join at that NF, which implies confluence.


  \item \textbf{Non-confluent, Terminating, No Unique NFs:}
  Example: ARS \#4 with $A=\{a,b,c\}, R=\{(a,b),(a,c)\}$.  
  \[
  \begin{tikzcd}[column sep=2.2em]
    a \arrow[r] \arrow[dr] & b \\
    & c
  \end{tikzcd}
  \]
  This system is terminating but it is not confluent, since $a$ reduces to two distinct forms $b$ and $c$.

  \item \textbf{Non-confluent, Non-terminating, Unique NFs:}
  Impossible. Having unique normal forms implies confluence so this case cannot exist.

  \item \textbf{Non-confluent, Non-terminating, No Unique NFs:}
  Example: ARS \#6 (or \#7).  
  \[
  \begin{tikzcd}[column sep=2.2em]
    & a \arrow[dl] \arrow[dr] & \\
    b \arrow[self, from=2-1, to=2-1] & & c \arrow[self, from=2-3, to=2-3]
  \end{tikzcd}
  \]
  From $a$ you can go to $b$ or $c$ but both loop on themselves. There are no normal forms so the system is non-terminating, non-confluent, and has no unique NFs.
\end{enumerate}

\noindent
\textbf{Notes:}
\begin{itemize}
  \item Two is impossible since termination and confluence always gives unique normal forms.
  \item Five is impossible since if every element has a unique normal form then confluence must hold.
  \item Seven is impossible for that same reason.
\end{itemize}

\subsection{Week 3}

\subsubsection{String Rewriting Exercise}

\paragraph{Exercise 5}
We consider the rewite rules:
\[
  ab \to ba, \quad
  ba \to ab, \quad
  aa \to , \quad
  b \to , \quad
  \]

\paragraph{Example reductions}
\[
\texttt{abba} \;\to\; \texttt{aba} \;\to\; \texttt{aa} \;\to\; \varepsilon,
\]
\[
\texttt{bababa} \;\to\; \texttt{aaaba} \;\to\; \texttt{aaaa} \;\to\; \texttt{aa} \;\to\; \varepsilon.
\]
Because of the swap rules ($ab \leftrightarrow ba$), there are many possible paths, including infinite loops.

\paragraph{Why the ARS is not terminating}
The two opposite rules $ab \to ba$ and $ba \to ab$ allow endless swapping:
\[
ab \to ba \to ab \to ba \to \cdots
\]
So the system is non-terminating.

\paragraph{Equivalence classes}
- We can insert and delete any $b$.
- We can insert and delete $aa$.
- We can swap $a$'s and $b$'s arbitrarily.

The only invariant is the \textbf {parity of the number of $a$'s}.
Two equivalnce classes arise:
\[
\begin{cases}
\text{Even number of $a$’s} \quad \leftrightarrow^* \; \varepsilon, \\
\text{Odd number of $a$’s}  \quad \leftrightarrow^* \; a.
\end{cases}
\]

\paragraph{Normal Forms}
Delete all $b$'s then repeatedly delete $aa$.
- If the string has an even number of $a$'s it reduces to $\varepsilon$.
- If it has an odd number of $a$'s it reduces to $a$.
So the normal forms are $\varepsilon$ and $a$.

\paragraph{Termination fix}
We can orient swap in only one direction:
\[
ba \to ab, \quad aa \to \varepsilon, \quad b \to \varepsilon.
\]
Using the measure "\# of $ba$ substrings + length," each step decreases this value, so the system terminates.
Equivalence classes remain unchanged.

\paragraph{Sematic Questions}
\begin{itemize}
  \item Does a string have an even number of $a$'s? (Yes if it reduces to $\varepsilon$.)
  \item What is the canonical representative? ($\varepsilon$ for even, $a$ for odd.)
\end{itemize}

\paragraph{Exercise 5b}
Now change the rule $aa \to \varepsilon$ to $aa \to a$:
\[
ab \to ba, \quad
ba \to ab, \quad
aa \to a, \quad
b \to \varepsilon.
\]

\paragraph{Equivalence classes}
- $aa \leftarrow a$ allows changing the number of $a$'s by $+1$ or $-1$ (but never reaching $a$ from $\varepsilon$).
- Therefore there are two classes:
\[
\begin{cases}
\text{Strings with no $a$} \quad \leftrightarrow^* \; \varepsilon, \\
\text{Strings with at least one $a$} \quad \leftrightarrow^* \; a.
\end{cases}
\]

\paragraph{Normal forms}
Delete all $b$'s then repeatedly apply $aa \to a$ until at most one $a$ remains.
Normal forms are again $\varepsilon$ and $a$.

\paragraph{Termination fix}
The system still loops under $ab \leftrightarrow ba$. As before we make it terminating by keeping one swap direction. The measure (\# of $ba$'s + length) still decreases, so terminating holds and the equivalnce classes remain unchanged.

\subsection{Week 4}

\subsubsection{Termination}

\paragraph{HW 4.1}
Consider the following algorithm:
\subsection*{Algorithm}
\begin{verbatim}
while b != 0:
    temp = b
    b = a mod b
    a = temp
return a
\end{verbatim}

\subsection*{Conditions for Termination}
The algorithm is well defined and terminates under the following conditions:
\begin{itemize}
    \item Inputs $a, b \in \mathbb{N}$ (non-negative integers).
    \item The \texttt{mod} operator is the standard remainder: for $a, b \in \mathbb{N}$ with $b > 0$, there exist unique $q, r$ such that $a = qb + r$ with $0 \leq r < b$.
    \item Thus, after \texttt{b = a mod b}, we always have $0 \leq b' < b$.
\end{itemize}

\subsection*{Measure Function}
Define the measure function:
\[
\mu(a,b) = b \in \mathbb{N}.
\]

\subsection*{Proof of Termination}
Suppose $b \neq 0$ before an iteration. The updated state is:
\[
(a', b') = (b,\, a \bmod b).
\]
By the remainder property, $0 \leq b' < b$. Hence:
\[
\mu(a', b') = b' < b = \mu(a,b).
\]
Thus $\mu$ strictly decreases at every iteration. Since $\mu$ takes values in $\mathbb{N}$, it is bounded below by $0$. Therefore, the loop must terminate.  

\noindent \textbf{Conclusion:} Under the given conditions, the algorithm always terminates.

\paragraph{HW 4.2}
Consider the following fragment of an implementation of merge sort:
\subsection*{Algorithm Fragment}
\begin{verbatim}
function merge_sort(arr, left, right):
    if left >= right:
        return
    mid = (left + right) / 2
    merge_sort(arr, left, mid)
    merge_sort(arr, mid+1, right)
    merge(arr, left, mid, right)
\end{verbatim}

\subsection*{Measure Function}
Define:
\[
\phi(left, right) = (right - left + 1).
\]
This is the length of the current subarray.

\subsection*{Proof of Termination}
\paragraph{Base Case.}  
If $left \geq right$, then $\phi(left, right) \leq 1$, and the function returns immediately (no recursion).

\paragraph{Recursive Case.}  
Assume $left < right$ so that $n = \phi(left, right) \geq 2$.  
Set $mid = \lfloor (left + right)/2 \rfloor$.

\begin{itemize}
    \item \textbf{First recursive call:}  
    \[
    \phi(left, mid) = (mid - left + 1) \leq \Big\lfloor \tfrac{n}{2} \Big\rfloor < n.
    \]
    \item \textbf{Second recursive call:}  
    \[
    \phi(mid+1, right) = (right - (mid+1) + 1) = (right - mid) \leq \Big\lceil \tfrac{n}{2} \Big\rceil < n.
    \]
\end{itemize}
Both recursive calls strictly reduce the measure.

\paragraph{Well-Foundedness.}  
Since $\phi$ maps to $\mathbb{N}$ and decreases strictly with each recursive call, and $\mathbb{N}$ under $<$ is well-founded, infinite recursion is impossible.

\noindent \textbf{Conclusion:} $\phi(left, right) = right - left + 1$ is a valid measure function for \texttt{merge\_sort}, hence the algorithm always terminates.

\subsection{Week 5}

\subsubsection{Lambda Calculus Workout: \texorpdfstring{$\alpha$}{alpha} \& \texorpdfstring{$\beta$}{beta} Rules}

We conisder the lambda calculus expression:
\[
\bigl(\lambda f.\,\lambda x.\; f(f\,x)\bigr)
\bigl(\lambda f.\,\lambda x.\; f(f(f\,x))\bigr).
\]
For clarity, define:
\[
M \equiv \lambda f.\,\lambda x.\; f(f\,x),
\quad
N \equiv \lambda f.\,\lambda x.\; f(f(f\,x)).
\]
Here $M$ represents the Church numeral $2$ (apply $f$ twice), and $N$ represents the numeral $3$ (apply $f$ three times).
The problem reduces to computing $M\,N$.

\subsubsection{Step-by-Step \texorpdfstring{$\beta$}{beta}-Reduction}

Produced by $\beta$-reduction (with safe $\alpha$-renaming where necesary):
\begin{align*}
  M\,N 
  &= (\lambda f.\,\lambda x.\; f(f\,x))\,N \\[4pt]
  &\xrightarrow{\ \beta\ }\; \lambda x.\; N(N\,x).
  \end{align*}

Now expand $N$:
\[
N = \lambda f.\,\lambda y.\; f(f(f\,y)) \quad \text{(renamed inner $x$ to $y$)}.
\]

\paragraph{Step 1: Evaluate $N\,x$.}
\[
N\,x = (\lambda f.\,\lambda y.\; f(f(f\,y)))\,x
\xrightarrow{\ \beta\ } \lambda y.\; x(x(x\,y)) \;\;=\; G.
\]

\paragraph{Step 2: Evaluate $N\,G$.}
\[
N\,G = (\lambda f.\,\lambda y.\; f(f(f\,y)))\,G
\xrightarrow{\ \beta\ } \lambda y.\; G(G(G\,y)).
\]

Since $G\,y = x(x(x\,y))$, repeated three times, this results in nine total applications of $x$.

\paragraph{Final Result:}
\[
M\,N \;\xrightarrow{\ *\ }\; \lambda f.\,\lambda x.\;
f(f(f(f(f(f(f(f(f\,x)))))))).
\]
This is the Church numeral $9$.

\subsubsection{Interpretation and Haskell Representation}
\paragraph{Mathematical Meaning.}
In general,
\[
(\lambda f.\,\lambda x.\; f^m x)\;(\lambda f.\,\lambda x.\; f^n x)
\;\equiv\; \text{Church numeral for } n^m.
\]
Here $m=2$ and $n=3$, giving $3^2 = 9$.

\paragraph{Haskell-style Version}
Using \texttt{*.hs} with Haskell highlighting in VS Code:
\begin{lstlisting}
-- M: apply f twice
m = \f -> \x -> f (f x)

-- N: apply f thrice
n = \f -> \x -> f (f (f x))

term = m n

-- Normal form (Church numeral 9):
nine = \f -> \x -> f (f (f (f (f (f (f (f (f x))))))))
\end{lstlisting}

\begin{remark}
  Working in VS code with Haskell syntax highlighting makes parenthesis and step-by-step redution clearer.
\end{remark}

\subsection{Week 6}

\subsubsection{Computing \texttt{fact 3} with \texttt{fix}, \texttt{let}, and \texttt{let rec}}

Following the computation rules (as given in prompt):
\[
\begin{aligned}
\texttt{fix}\;F &\;\to\; (F\,(\texttt{fix}\;F)),\\
\texttt{let}\;x = e_1\;\texttt{in}\;e_2 &\;\to\; ((\lambda x.\,e_2)\;e_1),\\
\texttt{let rec}\;f = e_1\;\texttt{in}\;e_2 &\;\to\; \bigl(\texttt{let}\;f = (\texttt{fix}\;(\lambda f.\,e_1))\;\texttt{in}\;e_2\bigr).
\end{aligned}
\]

For brevity, let
\[
\begin{aligned}
F &\;\triangleq\; \lambda f.\,\lambda n.\;\texttt{if}\;n=0\;\texttt{then}\;1\;\texttt{else}\;n * f\,(n-1),\\
\textit{FixF} &\;\triangleq\; \texttt{fix}\;F.
\end{aligned}
\]

\paragraph{Goal} Compute
\[
E_0 \;=\; \texttt{let rec}\;\texttt{fact} = \lambda n.\;\texttt{if}\;n=0\;\texttt{then}\;1\;\texttt{else}\;n * \texttt{fact}\,(n-1)\;\texttt{in}\;\texttt{fact}\;3.
\]

\subsubsection*{Labeled derivation}

\begin{lstlisting}
  -- <def of let rec>
  E1 = let fact = fix (\f. \n. if n=0 then 1 else n * f (n-1) in fact 3
  = let fact = FixF in fact 3)
  
  -- <def of let>
  E2 = ((\fact. fact 3) FixF)

  -- <beta-rule: substitute FixF or fact>
  E3 = FixF 3

  -- <def of fix>
  E4 = (F FixF) 3

  -- <beta-rule: apply F to FixF>
  E5 = (\n. if n=0 then 1 else n * FixF (n-1)) 3

  -- <beta-rule>, <if-false>, <arith>
  E6 = 3 * FixF (3-1) = 3 * FixF 2

  -- Unfold FixF at 2
  -- <def of fix>
  E7 = 3 * (F FixF) 2
  -- <beta-rule>
  E8 = 3 * ((\n. if n=0 then 1 else n * FixF (n-1)) 2)
  -- <beta-rule>, <if-else>, <arith>
  E9 = 3 * (2 * FixF (2-1)) = 3 * (2 * FixF 1)
  
  -- Unfold FixF at 1
  -- <def of fix>
  E10 = 3 * (2 * (F FixF) 1)
  -- <beta-rule>
  E11 = 3 * (2 * ((\n. if n=0 then 1 else n * FixF (n-1)) 1))
  -- <beta-rule>, <if-else>, <arith>
  E12 = 3 * (2 * (1 * FixF (1-1))) = 3 * (2 * (1 * FixF 0))

  -- Base case at 0
  -- <def of fix>
  E13 = 3 * (2 * (1 * (F FixF) 0))
  -- <beta-rule>
  E15 = 3 * (2 * (1 *1))

  -- <arith>
  E16 = 3 * (2 * 1) = 3 * 2 = 6
\end{lstlisting}

\paragraph{Result} \(\texttt{fact}\;3 \Downarrow 6\)

\subsection{Week 7}

\subsubsection{Parse trees for Arithmetic Expressions}
In this hoemwork, I use the following context-free grammar:

\begin{verbatim}
  Exp -> Exp '+' Ex1 | Exp1
  Exp1 -> Exp1 '*' Exp2 | Exp2
  Exp2 -> Integer | '(' Exp ')'
\end{verbatim} 

Create derivation (parse) tress for each expression.

\subsubsection{Expression: 2 + 1}
\begin{forest}
[Exp 
  [Exp
    [Exp1
      [Exp2 [Integer [2]]]
    ]
  ]
  ['+']
  [Exp1
    [Exp2 [Integer [1]]]
  ]
]
\end{forest} 

\subsubsection{Expression: 1 + 2 * 3}
\begin{forest}
  [Exp
    [Exp [Exp1 [Exp2 [Integer [1]]]]]
    ['+']
    [Exp 1
      [Exp1 [Exp2 [Integer [2]]]]
      ['*']
      [Exp2 [Integer [3]]]
      ]
  ]
\end{forest}

\subsubsection{Expression: 1 + (2 * 3)}
\begin{forest}
  [Exp
  [Exp [Exp1 [Exp2 [Integer [1]]]]]
  ['+']
  [Exp1
    [Exp2
      ['(']
      [Exp
        [Exp1
          [Exp1 [Exp2 [Integer [2]]]]
          ['*']
          [Exp2 [Integer [3]]]
        ]
      ]
      [')']
    ]
  ]
]
\end{forest}

\subsubsection{Expression: (1 + 2) * 3}
\begin{forest}
  [Exp
  [Exp1
    [Exp1
      [Exp2
        ['(']
        [Exp
          [Exp [Exp1 [Exp2 [Integer [1]]]]]
          ['+']
          [Exp1 [Exp2 [Integer [2]]]]
        ]
        [')']
      ]
    ]
    ['*']
    [Exp2 [Integer [3]]]
  ]
]
\end{forest}

\subsubsection{Expression: 1 + 2 * 3 + 4 * 5 + 6}
\begin{forest}
  [Exp
  [Exp
    [Exp
      [Exp
        [Exp1 [Exp2 [Integer [1]]]]
        ['+']
        [Exp1
          [Exp1 [Exp2 [Integer [2]]]]
          ['*']
          [Exp2 [Integer [3]]]
        ]
      ]
      ['+']
      [Exp1
        [Exp1 [Exp2 [Integer [4]]]]
        ['*']
        [Exp2 [Integer [5]]]
      ]
    ]
    ['+']
    [Exp1 [Exp2 [Integer [6]]]]
  ]
]
\end{forest}


\section{Essay}

\section{Evidence of Participation}

\section{Conclusion}\label{conclusion}

\begin{thebibliography}{99}
\bibitem[BLA]{bla} Author, \href{https://en.wikipedia.org/wiki/LaTeX}{Title}, Publisher, Year.
\end{thebibliography}

\end{document}
